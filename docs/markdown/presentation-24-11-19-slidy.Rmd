---
title: "Atelier premiers pas avec R"
author: "Caroline Patenaude"
date: "20 novembre 2019"
output:
  slidy_presentation: 
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## 1. Pourquoi **R**? 


- **R** : logiciel et langage de programmation libres pour l’analyse statistique et graphique (etc.).
- Gratuit!
- Multiplateforme : Windows, Mac, Linux.
- Très fort pour les graphiques et visualisations de toutes sortes.
- Communauté très active donc développement constant.
- Pour tous les types d’analyses (modèles linéaires, multi-niveaux, analyses factorielles, simulations, …)
- Nombreuses méthodes non disponibles dans logiciels commerciaux – rapidité de l’implémentation de nouvelles méthodes.
- Utilisation de scripts assure la reproductibilité des analyses.
- Très efficace pour la création de présentations et de rapports (Rmarkdown, formation à venir!)

___


<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/cars.jpg)

</center>

## 2. Quelques bémols  

- Plus un langage de programmation qu’un logiciel.
- Principales ressources et aide en anglais.
- Ne voit pas directement les données comme SPSS, excel… Les fichiers de données sont des objets en mémoire.
- L’affichage des résultats est très minimaliste.
- Prolifération des fonctions (*packages*) peut alourdir l’apprentissage.
- Contient généralement de l’aide pour toutes les fonctions mais pas toujours facile à comprendre.
- Développement rapide fait que la documentation laisse parfois à désirer.
- S’adresse avant tout à des usagers avancés (comme SAS) mais ça s’apprend!
- Comme pour tout language de programmation, un "rien" peut faire en sorte que ça plante :-(
- Bref, complexe mais TRÈS puissant!


## 3. **RStudio** (et autres IDE)  

- Interface du **R** de base pas très intuitive donc peu utilisée telle quelle.

- Installe généralement en plus un IDE,  *Integrated Development Environment*:  éditeur de script - environnement beaucoup plus convivial qui facilite le travail (gestion des fichiers, objets et commandes, historique de fonctions, autocomplétion,…)
- L’IDE le plus utilisé est **RStudio** (mais il y en a d’autres comme **Tinn-R**).

- Les commandes et fonctions sont les mêmes pour **R** et **RStudio**.

- Une version [*cloud*](https://rstudio.cloud/) de RStudio est disponible gratuitement (pour le moment...)

- Existe aussi un package nommé Rcommander qui permet d’automatiser les fonctions et donc de travailler en *point-and-clic* (va à l’encontre de la philosophie du logiciel).

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/screenshotR.png)

</center>

## 4. Installation  

1. Télécharger et installer [**R de base**](https://cran.r-project.org/) - choisir son système d’exploitation et suivre les étapes.

2. Télécharger et installer  [**R de base**](https://www.rstudio.com/products/rstudio/download/#download) (ou autre interface) – Choisir la version gratuite et son système d’exploitation.

3. Télécharger et installer ("charger") des *packages* dans **RStudio**

   - À noter
      + Pas de mises à jour automatiques, il faut installer une nouvelle version et retélécharger les *packages* (ou déplacer le répertoire de l’ancienne version et faire `update.packages`). **RStudio** utilisera par défaut la version la plus récente sur le poste (peut se faire manuellement). L'ancienne version peut être désinstaller.

      + Pour installer `Rcommander`, préférable d’utiliser le **R** de base et non **RStudio** et exécuter la commande: install.packages("Rcmdr")  


## 5. Qu’est-ce qu’un *package*? 


- Un *package* est un module (ou extension, librairie, bibliothèque) qui contient un ensemble de fonctions.
- À l’installation, **R** vient avec un ensemble de fonctions de base {base} et de modules par défaut (*built in packages*).
- Des *packages* avec fonctions spécialisées sont constamment développés par la communauté.
- Sur le site officiel de **R** [CRAN](https://cran.r-project.org/). D'autres se trouvent aussi ailleurs (Github*, …).
- Les packages doivent être **téléchargés** une seule fois, mais **chargés** (`library()`) à chaque session
- Une fonction (ex: corrélation, tableaux contingences…) peut se retrouver dans plusieurs packages avec variantes plus ou moins importantes (procédures, options, arguments, résultats).
- Plusieurs fonctions du même nom peuvent se retrouver dans différents packages. Il faut alors désambiguïser le nom de la fonction voulue:
    + psych::describe()	
  	+ Hmisc::describe()


## 5. Qu’est-ce qu’un package? (suite)  

- Il y a toujours plusieurs façons d’arriver au même résultat -> normal et nécessaire de se limiter à certaines fonctions.

- Les modules sont généralement évalués par les pairs - [Journal of Statistical Software](https://www.jstatsoft.org/index) – le choix doit se faire avec précautions.

- Comment les trouver et les choisir? En cherchant sur Google! En s’informant dans son domaine et en vérifiant si les packages ont déjà été utilisés dans des publications.

- Certains packages ont des façons spécifiques de fonctionner. Ils utilisent une syntaxe et des formats qui se distinguent de la syntaxe commune de **R**. 


## 6. Tidyverse  {.smaller}
 <center>

![Packages Tidyverse](C:/Users/p0373489/Desktop/AtelierR/markdown/tidyverse.png)

</center>  

- Ensemble de packages très utilisé spécialisé dans l’analyse, la manipulation et la visualisation de données.
- Les packages Tidyverse partagent une syntaxe commune spécifique (ex: %>%)
- Travaillent avec un format de jeu de données particulier (*tibble*) – variation sur le dataframe.
- La commande `install.packages("tidyverse")` va télécharger toutes les extensions constituants le cœur de tidyverse:
    + dplyr (manipulation des données)
    + tidyr (remise en forme des données)
    + purrr (programmation)
    + readr (importation de données)
    + tibble (tableaux de données)
    + forcats (variables qualitatives)
    + stringr (chaînes de caractères)
    + ggplot2 (visualisation)



## 7. Interface **RStudio**  

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/interface.jpg)

</center>  

  - À noter:
    + On ne peut conserver l'historique complet à partir de la console, donc il est préférable de travailler à partir d'un script.
    + Ctrl + Entrée est votre meilleur ami! : exécute le code dans le script ligne par ligne.
    + L'onglet *history* permet de consulter l'historique des commandes et de les relancer dans la console en double-cliquant sur une ligne.
    + l'*invite de commande* se transforme parfois en +, **R** considère alors que la ligne de commande n'est pas complète. Pour en sortir, tapper sur *esc*.
    + Il est recommandé de ne pas faire de scripts trop longs, on peut les diviser en différents fichiers et les appeller via la fonction source("NomScript.R")
    
    
    
## 8. Les projets et autres fichiers dans **RStudio** 


- Un projet permet d’organiser son travail et de faciliter l’accès à un ensemble de fichiers (données, scripts, documentation, etc.) organisés dans des dossiers/sous-dossiers.
- menu *File* puis sélectionner *New project*.
- Un projet **RStudio** est associé à un répertoire de travail **R**: on peut alors créer un nouveau dossier ou créer un projet à partir d’un dossier existant.
- **R** va créer dans ce dossier un fichier **.Rproj**. Ce fichier sera ensuite automatiquement chargé dans **RStudio** à l’ouverture entrainant la définition du dossier de travail, le chargement du fichier .Rdata (contenant les objets), le chargement de l'ihstorique et l’ouverture des scripts ouverts à la dernière session. 
- On peut définir les réglages d’un projet sous *Tools >  Project option*.
- Même si l’on ne travaille pas dans le cadre d’un "projet", **R** demandera à la fermeture si l’on veut enregistrer ce qui se trouve dans son environnement. Si on répond oui, les objets seront enregistrés dans un fichier .Rdata et les commandes enregistrées dans un fichier .Rhistory. À la prochaine ouverture **R** ouvrira comme au dernier enregistrement.
- Certains préfèrent travailler seulement à partir de scripts.


## 9. **R**: Langage de programmation  


- **R** est avant tout un langage de programmation orienté objet.
- Développé à partir du **langage S** par *Ross Ihaka* et *Robert Gentleman* au cours des années ‘90.
- Permet de programmer ses propres fonctions et packages.  

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/programmation.png)

</center>  



## 9. **R**: Langage de programmation (suite)  


Particularités à savoir:

- Sensible à la casse.
- Sensible aux accents (éviter d’utiliser).
- Sensible aux signes de ponctuation: point pour décimales, virgule pour adressage.
- Non sensible aux espaces.
- Attention aux guillemets (pour texte, simple ou double), crochets, accolades, parenthèses.
- Une ligne par commande, ou séparer plusieurs commandes par ;
- Importance fondamentale de documenter son code avec  #  
`# ceci est un commentaire (peut ajouter section avec au moins 4 ----)`
- Contrairement aux autres logiciels, l’analyse se fait par une série d’étapes avec des résultats intermédiaires stoqués dans des objets.


## 10. Structure de base du langage **R**: Objets  


<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/objet.jpg)

</center>  

## 10. Structure de base du langage **R**: Objets (suite) 


À la base, on peut utiliser **R** comme une grosse calculatrice:

```{r, echo = TRUE}
2+2
```


**WOW!**

- Mais l’intérêt du langage est que l’on stoque les valeurs, les tableaux, résultats, fonctions, ... dans des objets qui pourront être réutilisés dans d’autres objets, fonctions, analyses.

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/assignation.jpg)

</center>  

*On remarque la présence du `[1]` en début de ligne devant le résultat. Ce nombre entre crochet indique la position du 1er élément de la ligne, ie l'index. Comme nous le verrons, ce principe **d'indexation** permet de sélectionner et de modifier des éléments en indiquant leur numéro entre crochets...* 

## 10. Structure de base du langage **R**: Objets (suite)  

Les noms d’objets:

- Peuvent contenir des chiffres, lettres et caractères _ et .
- Doivent commencer par une lettre, pas un chiffre.
- Ne pas utiliser d’accents ni d’espace.
- En principe il faut utiliser des noms significatifs, en pratique on utilise souvent des noms minimalistes pour faciliter - la réutilisation (xx, aa, ss).
- Certains noms courts sont réservés (max, min, c, q, t, …).

*Il existe plusieurs guides de bonnes pratiques de mise en forme de script dont:  [Advanced R Style Guide, Hadley Wickham](http://adv-r.had.co.nz/Style.html), [The Tidyverse Style Guide](https://style.tidyverse.org/)*


## 10. Structure de base du langage **R**: Objets (suite)  


```{r, echo = TRUE}
(12+15+20)/3  # Je peux calculer une moyenne
```


```{r, echo = TRUE}
aa <- (10+15+20)/3  # Je peux créer un objet dans lequel je stoque le résultat du calcul
```


```{r, echo = TRUE}
aa # Pour voir le contenu de son objet, tapper son nom

```


```{r, echo = TRUE}
print(aa)  # Utilisation implicite de la fonction print(objet)

```


## 10. Structure de base du langage **R**: Objets (suite)  


- Les objets créés apparaitront dans le fenêtre environnement de droite en différentes section selon le type d’objet créés

- On peut aussi visualiser certains types d’objets (listes, dataframes, …) 

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/environnement.png)

</center>  

**Un objet peut donc être composé d'un seul chiffre, d'un mot, ou d'un jeu de données d'un million de répondants.**

## 11. Opérateurs d’assignation  


#### 3 opérateurs d'assignation (<em>assignment</em>) - Opérateurs qui permettent de créer un objet: `<-`, `->`, `=`

&nbsp;
&nbsp;

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/operateurs.jpg)

</center>  

## 12. Structure de base du langage **R**: Fonctions  


<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/fonction.jpg)

</center>

- Permettent d’effectuer des tâches prédéfinies comme des analyses, graphiques, calculs, … (tableaux, régressions, histogrammes, …)
- On contrôle le comportement de la fonction en paramétrant ses **arguments** (paramètres)
- Certaines fonctions ne s’appliquent qu’à certains types d’objets, d’autres adapteront leur fonctionnement (résultat) selon le type de données fourni.
- On peut imbriquer les fonctions les unes dans les autres avec des parenthèses.

## 12. Structure de base du langage **R**: Fonctions (suite)  

- Je veux créer un **objet** composé d’une série de 3 nombres: 12, 15, 20 (ie un vecteur, nous y reviendrons…)
- Il faut utiliser la fonction de base `c()`: concaténer (ou combiner)
```{r, echo = TRUE}
Objet <- c(12, 15, 20)
# Objet = nom de notre objet
# c = fonction de concaténation
# () = premier argument de notre fonction, ie nos données
```

- Je veux calculer la moyenne des 3 valeurs stockées dans mon **Objet**
- J'utilise la fonction `mean()` :
```{r, echo = TRUE}
mean(Objet) # Je passe mon Objet comme argument de la fonction `mean()`
```
- Je veux arrondir mon résultat à seulement une décimale
```{r, echo = TRUE}
round(mean(Objet), digits=1) # J’imbrique la fonction `mean()` dans la fonction `round()`
```

## 13. Structure de base du langage **R**: Arguments 

- Chaque fonction possède une liste plus ou moins longue d’arguments plus ou moins complexes permettant de paramétrer le fonctionnement de la fonction.

- Le premier argument = toujours les données (on ne le nomme généralement pas x=)

- Certains arguments ont une valeur par défaut. Si ces valeurs nous conviennent, pas besoin de les indiquer.

- Si l’argument n’a pas de valeur par défaut, FAUT le renseigner.

- Pour modifier la valeur d’un argument, on le nomme et change sa valeur à la suite d’un =. 

- La liste d’arguments respecte un ordre. Si on modifie chaque argument dans l’ordre, on peut omettre le nom des arguments. Les arguments peuvent donc **être nommés ou non nommés**.

- Comment savoir quels sont les arguments d’une fonction? Tapper `Help(NomFonction)` ou `args(NomFonction)`.


## 13. Structure de base du langage **R**: Arguments (suite)  

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/aide.jpg)

</center>
```{r, echo = TRUE}
mean(c(10, 15, NA, 20)) # OUPS!
```
```{r}
# ?mean
```

```{r, echo = TRUE}
mean(c(10, 15, NA, 20), na.rm=TRUE, trim=.05)
# Argument 1: utilise la fonction c(), ie concaténation, pour créer un vecteur
# Argument 2: lui dit d’ignorer les valeurs manquantes dans le calcul
# Argument 3: ignorer les 5% de valeurs extrêmes

```

## 14. Types de données  


Comme tout logiciel d’analyse quantitative, **R** permet de créer et de manipuler plusieurs types de données. On parle en général du **mode** d’un objet. Les types de base* sont:

- *Character*: texte entre guillemets ("x" ou ‘x‘).
- *Numeric* (aussi *real* ou *double*), *integer* (entier), *complex*, *raw* : différents formats numériques.
- *Logical*: valeurs booléennes - TRUE, FALSE.
```{r, echo = TRUE}
ss <- 123      # Numérique
dd <- "soleil" # Chaîne de caractères
ff <- TRUE     # Logique (T/F)
gg <- "123"    # ???

```
Pour vérifier le type de données : `mode(NomObjet)`

  -À noter
    + On retrouve également des types dérivés comme les dates, les **facteurs**, les vecteurs labellisés qui ont des **attributs** particuliers.
    + Dans R les valeurs manquantes sont identifiés par NA (n'accepte pas par défaut les codes de valeurs manquantes comme 9, 99). NA est une valeur de type *Logical* qui est comptée comme un élément du vecteur (contrairement à la valeur NULL qui est vide).



## 15. Types d’objets  

En plus du **mode** définissant le format de leurs éléments/composantes, les objets sont aussi caractérisés par différentes **structures**: les vecteurs, les listes, les matrices (à deux dimensions ou plus, ie array) et les tableaux (dataframe). Ce sont donc 5 différents types de contenants ayant chacun leurs propriétés.  
<center>
![](C:/Users/p0373489/Desktop/AtelierR/markdown/types.jpg)

</center>

## 15. Types d’objets (suite)  

Pour vérifier le type de structure: `class(NomObjet)`  
<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/tobjet.jpg)

</center>

## 15.1 Les vecteurs  

- La brique élémentaire = série de valeurs (en pratique, une variable).
- Contient un ou plusieurs éléments de **même type (mode)**.
- Élément à une seule dimension, ie **longueur** `length()`.
- Dans le fond, tout est composé de vecteurs – par exemple les tableaux sont composés de vecteurs (variables).
- Attribut une série de valeurs à un vecteur en utilisant la fonction `c()`.
- Les valeurs d’un vecteur sont toujours positionnées selon leur **rang** dans la série de données ce qui permet la sélection par **indexation** (à suivre...).

## 15.1 Les vecteurs  (suite)  

Un vecteur d’un seul élément numérique
```{r, echo = TRUE}
aa <- 6  
aa
```

Un vecteur de plusieurs éléments numériques
```{r, echo = TRUE}
bb <- c(5, 23, 89)
bb
```

Un vecteur textuel
```{r, echo = TRUE}
cc <- c("bleu", "blanc")
cc
```

Un vecteur booléen
```{r, echo = TRUE}
dd <- c(TRUE, FALSE, FALSE, TRUE) 
dd
```

## 15.1.1 Les vecteurs - La coercition  
  

- On peut combiner des vecteurs, mais attention à la **coercition**
```{r, echo = TRUE}
bb <- c(5, 23, 89)
cc <- c("bleu", "blanc")
ee <- c(bb,cc) # combinaison d'un vecteur numérique et d'un vecteur textuel
ee
```

Lorsque l’on créé un objet avec des éléments de **différents types** (texte, numérique,…) alors qu’ils devraient être du même type, **R** va forcer implicitement la conversion des formats pour qu’il n’y ait qu’un **type unique**.
```{r, echo = TRUE}
c(1,2,"allo", TRUE) 
```

## 15.1.2 Les vecteurs - Le recyclage 
  
  
- On peut faire calculs avec les vecteurs, mais attention au **recyclage**
```{r, echo = TRUE}
ff <- aa/bb # calcul d'un vecteur d'un élément avec un vecteur de 3 éléments
ff
```

Les opérations mathématiques entre vecteurs sont effectuées **élément par élément**. Lorsque l’on effectue des opérations entre vecteurs de longueurs différentes, **R** répète les éléments du vecteur plus court pour qu’il ait la même longueur que le plus long. 
```{r, echo = TRUE}
c(1,2) + c(1,2,3,4,5,6)

```


![](C:/Users/p0373489/Desktop/AtelierR/markdown/recyclage.jpg)

## 15.1.3. Les vecteurs "nommés"  

- Les valeurs d’un vecteur peuvent être nommés.
- Ces étiquettes sont considérées comme des **attributs** (métadonnées) 
- 2 façons de faire:  

1. Dès la création du vecteur:
```{r, echo = TRUE}
francais <- c(etudiant1=86, etudiant2=75, etudiant3=59, etudiant4=88, etudiant5=69) 
```
```{r, echo = TRUE}
francais
```


2. Après la création du vecteur en créant un vecteur de noms et en utilisant la fonction `names()`:
```{r, echo = TRUE}
francais <- c(86, 75, 59, 88, 69)
etudiants<-c("etudiant1", "etudiant2", "etudiant3", "etudiant4", "etudiant5") 
names(francais)<-etudiants
```
```{r}
francais
```

  *La fonction `unname()` permet de supprimer les noms d'un vecteur*

## 15.2 Les facteurs  

- Lors de l’importation de données, tout dépendant de la fonction utilisée pour importer, les variables qualitatives seront soit importées sous forme de **vecteur textuel** ou seront converties en **facteur**.
- Les fonctions d’importation des *packages* *tidyverse* (readr, readxl ou haven) importent les variables qualitatives sous forme textuelle, mais la majorité des fonctions d’importation les convertissent en facteur.
- Il est toujours possible de convertir en facteur le format d’une variable numérique/textuelle  avec la fonction `as.factor` (ou l’inverse avec `as.numeric`, `as.character`).  

NB parce que les valeurs sont stoquées sous forme numérique et que les niveaux ne sont qu’un attribut textuel, les facteurs sont considérés comme étant plus économiques en terme d’espace. Peuvent être plus contraignants à manipuler, mais très pratiques pour plusieurs fonctions.


## 15.2 Les facteurs (suite)  

<center>

![](C:/Users/p0373489/Desktop/AtelierR/markdown/facteurs.jpg)

</center>


## 15.3. Listes  

- Une liste est une sorte de vecteur, donc unidimensionnel, mais qui peut contenir n’importe quel type de données donc objet très flexible.
- Dit qu’elle est *récursive* car peut elle-même être composée d’autres types d’objets dont d’autres listes (contrairement aux vecteurs dits *atomiques*).
- Souvent utilisé comme argument à une fonction.
- Comme le vecteur, la liste a une longueur `length()` et possède des valeurs qui peuvent être nommées (vecteur de nom comme attribut).
- La longueur d'une liste correspond au nombre d'éléments qu'elle contient.
- Chaque élément d'une liste peut donc avoir ses propres dimensions.
- On créé de listes grâce à la fonction `list()` et les fusionne avec `append()`.

## 15.3. Listes (suite)  

Ça c’est un vecteur
```{r, echo = TRUE}
aa <- c(2, 5, 3) 
aa
```
Une liste avec des numériques, du texte, du booléen et un vecteur  

```{r, echo = TRUE}
bb <- list(65, 1886, "patates", "frites", TRUE, aa) 
bb
```

Sélection du 1er élément du 6e élément de la liste, donc 2  
```{r, echo = TRUE}
bb[[6]][1] 
```

## 15.4 Matrices  


- Une matrice c’est un tableau (lignes et colonnes)
- Résulte d’une combinaison de vecteurs à deux dimensions avec une classe *matrix.*
- Comme le vecteur, les valeurs doivent être toutes de **même type** - tout numérique, tout textuel,… (sinon ça devient un *DataFrame*).
- Concrètement on les utilise rarement, elles sont utilisées en arrière-plan dans certains calculs complexes (analyse spatiale, calcul matriciel,...), mais parfois nécessaires pour certaines fonctions.  

On crée un vecteur avec la fonction c()
```{r, echo = TRUE}
vecteur <- c(1,2,3,4,5,6,7,8,9,10)
```

On crée une matrice avec la fonction matrix() et lui passe notre vecteur en spécifiant en argument le nombre de lignes et de colonnes
```{r, echo = TRUE}
matrice <- matrix(vecteur, nrow=5, ncol=2) 
```

```{r, echo = TRUE}
matrice
```

OU on fait tout d’un coup
```{r}
matrice2 <- matrix(c("a", "b", "c", "d"), nrow=2, ncol=2)
matrice2
```

## 15.5 Arrays  

- Une matrice en trois dimensions, ie un **cube**.
- C’est donc un vecteur à plus de deux dimensions et une classe implicite *array.*
- Organisé en couches ou strates.
- Plus rare, pas utilisé au premier plan.
```{r, echo = TRUE}
Array1 <- array(c("bleu", "blanc", "rouge"), dim=c(2, 3, 4))
# On crée un vecteur avec la fonction `c()`
# `dim=c()` spécifie nombre de lignes, colonnes et strates.

```

## 15.6. DataFrame  

- Jeu de données = tableur excel, spss, …
- On le crée rarement à la main, on importe généralement un fichier de données. 
- Avec le vecteur, type d’objet qu’on utilise le plus souvent.
- Sont en fait des listes composées de **vecteurs nommés** (noms uniques) de même **longueur** (colonnes) mais qui peuvent être de **modes différents** (variables numériques, textuelles, logiques)
- On les crée avec la fonction `data.frame()` - les variables textuelles seront automatiquement converties en **facteur** (sinon il faut modifier l'argument - `stringsAsFactors = FALSE)`)
- Tout comme les colonnes qui ont un nom, les lignes peuvent aussi être nommées – `rownames()`.
- C’est donc une **liste bidimentionnelle** avec des colonnes - `ncol()`, des lignes - `nrow()`. Donc 2 dimensions - `dim()`.
- La fonction `length()` renverra le nombre de colonnes et `names()` leur nom.

## 15.6. DataFrame (suite)  


  1. On créé 3 objets vecteurs (variables: sexe, age, groupe)
  2. On les relie dans un tableau avec la fonction `data.frame()`
  3. On créé un objet **bd** dans lequel on placera notre tableau de données
```{r, echo = TRUE}
sexe <- c("F", "H", "F", "F")
age <- c(12, 16, 10, 14)
groupe <- c("A", "B", "B","A")
bd <- data.frame(sexe,age,groupe)

```
```{r, echo = TRUE}
bd
```

   4. Ou d’un coup avec la fonction `data.frame`, on crée nos vecteurs et notre tableau que l’on placera dans l’objet **bd**.
```{r, echo = TRUE}
bd2<-data.frame(sexe = c("homme", "femme", "femme", "homme"), age=c(34, 56, 21, 60), group=c("A", "B", "B","A"))
```
```{r}
bd2
```

*Les fonctions `cbind()` et `rbind()` permettent de combiner des éléments par colonne ou par ligne.*

## 15.7 Résumé: Types d’objets et fonctions utiles  


- Les objets dans **R** sont caractérisés par différentes propriétés : ils possèdent au minimum un `mode()`, le type de base de ses composantes, et une longueur – `length()` - le nombre de composantes. 

- La fonction `typeof()` est très similaire au mode; elle offre une description un peu plus précise du format de stockage interne d’un objet.

- Les objets ont aussi une `classe()` : c’est une propriété assignée à un objet pour définir l’information contenue ET déterminer la façon dont l’objet sera traité par certaines fonctions dites génériques (comme `print()`, `summary()`, `plot()`). Pour les vecteurs simples, la classe est implicite et correspond au mode. 

- Bref, le **mode**, le **type** et la **classe** sont souvent pareils, mais pas toujours! La fonction `str()` peut aussi être utile pour plus de détails sur un objet et ses éléments.

- Les objets, en plus de leurs composantes, peuvent aussi posséder des attributs - `attributes()` – métadonnées contenant des informations additionnelles sur l'objet comme des noms - `names()` - et des dimensions - `dim()`.
`names()`: les noms - étiquettes des éléments.
`dim()`: les dimensions, ie nb de colonnes/lignes dans tableaux.

NB il est possible de convertir le type (mode) d’un objet avec: `as.character()`, `as.list()`, `as.numeric()`, `as.factor()`. Pour vérifier le format, remplacer as. par is : `is.character()`, `is.list()`, `is.numeric()`, `is.factor()`, 


## 16. Indexation  

Fonctionnalité permettant d'utiliser des Opérations afin de sélectionner des valeurs en fonction de différents critères

Trois types d'indexation (*indiçage*):
    1. par position (directe)
    2. par nom
    3. par conditions logiques 

- Tous reposent sur le même principe: on utilise des opérateurs - soit des crochets (`[]`, `[[]]`) ou le signe `$` (si l’élément est nommé) pour identifier les valeurs spécifiques que l'on souhaite sélectionner ou pas.

- Pour une liste (donc incluant tableaux), on utilise`[]` pour sélectionner les éléments d'une liste (sous forme de liste), `[[]]` pour sélectionner le contenu de l'élément de la liste (par position ou par "nom") ou si l'élément est nommé, l'opérateur `$` (raccourci pour sélectionner un élément par son nom).


## 17.1. Indexation par position  

**Exemple**  
On créé 3 vecteurs nommés correspondant aux notes dans 3 cours de 5 étudiants
```{r, echo = TRUE}
francais <- c(etudiant1=86, etudiant2=75, etudiant3=59, etudiant4=88, etudiant5=69)
anglais <- c(etudiant1=59, etudiant2=71, etudiant3=62, etudiant4=79, etudiant5=58)
biologie <- c(etudiant1=57, etudiant2=85, etudiant3=65, etudiant4=61, etudiant5=97) 

```

On veut sélectionner seulement les éléments de 1 à 4 du vecteur biologie
```{r, echo = TRUE}
biologie[1:4] 
```

On veut sélectionner seulement les éléments 1, 3 et 5 du vecteur anglais
```{r, echo = TRUE}
anglais[c(1,3,5)] 
```

On veut sélectionner tous les éléments du vecteur francais sauf le premier et le cinquième
```{r, echo = TRUE}
francais[c(-1, -5)]
```

## 17.2. Indexation par nom  

Si les vecteurs sont nommés, on peut accéder aux valeurs par leurs noms (le sauf "–"" ne s’utilise pas, il faut utiliser la condition `!=`)
```{r, echo = TRUE}
anglais[c("etudiant1", "etudiant5")] 
anglais[names(anglais) != "etudiant1"]
```

## 17.3. Indexation par condition logique  

Opérations logiques de comparaison qui renvoient `TRUE` ou `FALSE` pour chacun des éléments d’un vecteur = Test de critères de sélection via une série d’opérateurs.

On utilise un opérateur pour définir une condition de sélection qui retourne une liste de valeurs logiques
```{r, echo = TRUE}
francais>70 
```

On insère cette condition entre crochets pour sélectionner les valeurs qui remplissent la condition
```{r, echo = TRUE}
francais[francais>70] 
```

## 17.4 16.1. Indexation + Assignation  

L’indexation permet aussi de modifier des valeurs sélectionnées
```{r, echo = TRUE}
francais[2]<-88 # remplace la deuxième valeur du vecteur par 88
francais[francais==86]<-77 # remplace toutes les valeurs égales à 86 du vecteur par 77
francais[2] <- anglais[1] # remplace la deuxième valeur du vecteur francais par la première valeur du vecteur anglais

```

## 18. Raccourcis pratiques  

- **Éditeur**:
    + Ctrl + Entrée: exécute code dans le script ligne par ligne.
    + Ctrl + 2: déplace curseur dans la console.

- **Console**:
    + Ctrl + 1 : déplace le curseur dans l’éditeur.
    + Ctrl + l : vide la console
    + Flèche vers le haut et bas du clavier: historique des commandes précédentes.

- Onglet History du quadrant haut-droite: consulter et relancer commandes.

- Autocomplétion: Tab dans le nom d’une fonction. Aussi pour nom d’objets.

- Nombreux autres raccourcis sous l’onglet *View*

## 19 Importer un fichier de données  

Il existe plusieurs fonctions/packages pour importer des fichiers de divers formats. Chaque fonction a ses particularités qui auront un impact sur la conversion des données (par exemple comment seront traitées les valeurs manquantes, les étiquettes de variables, les dates).

- Privilégier l'importation de fichiers textes (.txt ou .csv)
- Avant d’importer un fichier, il est donc impératif de se familiariser avec son contenu et sa structure:
- Quel est le type de séparateur de valeurs: tab, virgule, point-virgule.
- Quel est le séparateur de décimale: , ou . (. par défaut, sinon faut le spécifier)
- Est-ce que la première ligne contient le nom des variables.
- Y a-t-il des valeurs manquantes et comment sont-elles identifiées (88-99, NA, cellule vide, …) – idéalement utiliser NA.
- Les variables sont de quels types (nominales, ordinales, continues)
- Les valeurs sont de quels formats (chaine de caractères ou numérique)
- S’assurer que chaque ligne correspond à une observation et chaque colonne à une variable.

**Après l'importation, il est essentiel d'inspecter ses données de façon détaillée **

## 20. Pour aller plus loin  

- Joseph Larmarange et als, 2019, [Analyse-R Introduction à l’analyse d’enquêtes avec R et RStudio](https://larmarange.github.io/analyse-R/ )

- Julien Barnier, 2019, [R pour les débutants](https://juba.github.io/tidyverse/)

- Rebaudo, 2019, 
[Se former au logiciel R : initiation et perfectionnement](https://myrbookfr.netlify.com/myRBook_FR.pdf)

- Jean-Herman Guay, [Statistiques en sciences humaines avec R](https://atrium.umontreal.ca/primo-explore/fulldisplay?docid=UM-ALEPH002264738&context=L&vid=UM&search_scope=Tout_sauf_articles&isFrbr=true&tab=default_tab&lang=fr_FR)
    [+ Site pédagogique pour les usagers francophones de R](http://dimension.usherbrooke.ca/dimension/v2ssrcadre.html)


[Catalogue Atrium -  Sujet: R Langage de programmation](https://atrium.umontreal.ca/primo-explore/search?vid=UM&lang=fr_FR&sortby=rank&mode=advanced)

- [Rseek - Recherche Google dans ressources R seulement](http://www.rseek.org/)
- [The R Manuals (Guides de base)](https://cran.r-project.org/manuals.html)
- [CRAN Task Views (ressources spécialisées selon les "disciplines")](https://cran.r-project.org/web/views/)
- [Quick-R (pratique pour les fonctions)](https://www.statmethods.net/)
- [R Bloggers (se tenir informé)](https://www.r-bloggers.com/)
- [RStudio Cheat Sheets](fiches résumés)(https://rstudio.com/resources/cheatsheets/)
- [RDocumentation](http://www.rdocumentation.org/)
- [R for Data Science](https://r4ds.had.co.nz/)

Beaucoup de ressources intéressantes sur Github. Ex: [Exploratory Data Analysis in R](https://mgimond.github.io/ES218/index.html)

Poser des questions: (https://stackoverflow.com/) ...
